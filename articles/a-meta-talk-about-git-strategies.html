<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><title>Morten Olsen - A meta talk about Git strategies</title><meta property="og:title" content="A meta talk about Git strategies"/><meta name="next-head-count" content="4"/><script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.mortenolsen.pro/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script><link rel="preload" href="/_next/static/css/c460d6a22c298d9c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c460d6a22c298d9c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-3ce2c4e8ca835469.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-83840dae61bd0498.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8ab30062296419c0.js" defer=""></script><script src="/_next/static/chunks/143-7099d282e633d34a.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bid%5D-32290d5d1f52103c.js" defer=""></script><script src="/_next/static/6j-c-bk0BX_lPW9TYh8fm/_buildManifest.js" defer=""></script><script src="/_next/static/6j-c-bk0BX_lPW9TYh8fm/_ssgManifest.js" defer=""></script><script src="/_next/static/6j-c-bk0BX_lPW9TYh8fm/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">*{box-sizing:border-box;}/*!sc*/
html{font-size:16px;}/*!sc*/
h1,h2,h3,h4,h5,h6{margin:0;}/*!sc*/
html,body,body > #__next{height:100%;}/*!sc*/
body{margin:0;padding:0;font-family:'Merriweather',sans-serif;}/*!sc*/
a{-webkit-text-decoration:none;text-decoration:none;color:#3498db;}/*!sc*/
data-styled.g1[id="sc-global-ieejre1"]{content:"sc-global-ieejre1,"}/*!sc*/
.betbru{width:100%;max-width:800px;padding:0 30px;margin:auto;}/*!sc*/
data-styled.g2[id="content__Content-sc-1przdw9-0"]{content:"betbru,"}/*!sc*/
.cDfohR{font-size:2rem;padding:1rem 0;margin-top:50px;font-family:"Pacifico";}/*!sc*/
data-styled.g3[id="navigation__Menu-sc-1gzillj-0"]{content:"cDfohR,"}/*!sc*/
.dHNec{line-height:2.1rem;background:#fff;}/*!sc*/
.dHNec p + p:first-letter{margin-left:1.8rem;}/*!sc*/
.dHNec p:first-of-type::first-letter{font-size:6rem;float:left;padding:1rem;margin:0 1rem;}/*!sc*/
.dHNec p{-webkit-letter-spacing:0.5px;-moz-letter-spacing:0.5px;-ms-letter-spacing:0.5px;letter-spacing:0.5px;}/*!sc*/
.dHNec img{max-width:100%;margin:auto;}/*!sc*/
.dHNec h1{font-size:3rem;line-height:3.8rem;margin-bottom:0;}/*!sc*/
.dHNec h2{margin-top:5rem;}/*!sc*/
.dHNec h3{margin-top:3rem;}/*!sc*/
data-styled.g7[id="id__Wrapper-sc-1md5vsq-2"]{content:"dHNec,"}/*!sc*/
.betyHD{font-size:0.8rem;}/*!sc*/
data-styled.g8[id="id__Meta-sc-1md5vsq-3"]{content:"betyHD,"}/*!sc*/
.dXEVyO{width:100%;max-width:100%;float:both;}/*!sc*/
data-styled.g10[id="id__Cover-sc-1md5vsq-5"]{content:"dXEVyO,"}/*!sc*/
</style></head><body><div id="__next" data-reactroot=""><aside class="navigation__Menu-sc-1gzillj-0 cDfohR"><div class="content__Content-sc-1przdw9-0 betbru">by <a href="/">Morten Olsen</a></div></aside><div class="content__Content-sc-1przdw9-0 betbru"><article class="id__Wrapper-sc-1md5vsq-2 dHNec"><h1>A meta talk about Git strategies</h1><div class="id__Meta-sc-1md5vsq-3 betyHD"><time class="id__Published-sc-1md5vsq-4 lvwrH">5 days ago</time> <!-- --> - <!-- -->6<!-- --> minute read<!-- --> <!-- --> - <a href="/_next/static/assets/bce47cd04b92619ec50dd4a30f5ff179/doc.pdf" target="_blank">Download as PDF</a></div><img src="/_next/static/images/cover-297544fa0162192cde9a2269034c7fd2.png" class="id__Cover-sc-1md5vsq-5 dXEVyO"/><p>Let me start with a (semi) fictional story; It is Friday, and you and your team have spent the last five weeks working on this excellent new feature. You have written a bunch of unit tests to ensure that you maintain your project&#x27;s impressive 100% test coverage, and both you, your product owner and the QA testers have all verified that everything is tip-top and ready to go for the launch!
You hit the big &quot;Deploy&quot; button.
3-2-1
Success! it is released to production, and everyone gets their glass of Champagne!</p>
<p>You go home for the weekend satisfied with the great job you did.</p>
<p>On Monday, you open your email to find it flooded with customers screaming that nothing is working! Oh no, you must have made a mistake!!! So you set about debugging and quickly locate the error message in your monitoring, so you checkout the code from Git and start investigating. But the error that happens isn&#x27;t even possible. So you spend the entire day debugging, again and again, coming to the same conclusion; This is not possible.</p>
<p>So finally, you decide to go and read the deployment log line-by-painstakingly-line, and there, on line 13.318, you see it! One of your 12 microservices failed deployment! The deployment used a script with a pipe in it. Unfortunately, the script did not have pipefail configured. The script, therefore, did not generate a non-zero exit code, so the deployment just kept humming along, deploying the remaining 11 with success. This chain of events resulted in a broken infrastructure state and unhappy customers, and you spend the entire Monday debugging and potentially the ENTIRE EXISTANCE coming to an end!</p>
<p>I think most developers would have a story similar to the one above, so why is getting release management right so damn hard? Modern software architecture and the tools that help us are complex machineries, which goes for our deployment tools. Therefore ensuring that every little thing is as planned means that we would have to check hundreds, if not thousands of items, each more to decipher than the last (anyone who has ever tried to solve a broken Xcode builds from an output log will know this).</p>
<p>So is there a better way? Unfortunately, when things break, any of those thousands of items could be the reason, so when stuff does break, the answer is most likely no, but what about just answering the simple question: &quot;Is something broken?&quot;. Well, I am glad you asked because I do believe that there is a better way, and it is a way that revolves around Git.</p>
<h2>Git as the expected state</h2>
<p>So I am going to talk about Kubernetes, yet again - A technology I use less and less but, for some reason, ends up being part of my examples more and more often.</p>
<p>At its core Kubernetes has two conceptually simple tasks; it stores an expected state of the resources that it is supposed to keep track of two; if any of those resources are, in fact, not in the expected state, it tries to right the wrong.
This approach means that when we interact with Kubernetes, we don&#x27;t ask it to perform a specific task - We never tell it, &quot;create three additional instances of service X,&quot; but rather &quot;, There should be five instances of service X&quot;.
This approach also means that instead of actions and events, we can use reconciliation - no tracking of what was and what is, just what we expect; the rest is the tool&#x27;s responsibility.
It also makes it very easy for Kubernetes to track the health of the infrastructure - it knows the expected state. If the actual state differs, it is in some unhealthy state, and if it is unhealthy, it should either fix it or, failing that, raise the alarm for manual intervention.</p>
<p>So how does this relate to Git? Well, Git is a version control system. As such, it should keep track of the state of the code. That, to me, doesn&#x27;t just include when and why but also where - to elaborate: Git is already great at telling when something happened and also why (provided that you write good commit messages), but it should also be able to answer what is the code state in a given context.</p>
<p>So let&#x27;s say you have a production environment; a good Git strategy, in my opinion, should be able to answer the question, &quot;What is the expected code state on production right now?&quot;
And note the word &quot;expected&quot; here; it is crucial because Git is, of course, not able to do deployments or sync environments (in most cases) but what it can do is serve as our expected state that I talked about with Kubernetes.</p>
<p>Our target is to have something with the simplicity of the Kubernetes approach - we declare an expected state, and the tooling enforces this or alerts us if it can not.</p>
<p>Next, we need to ensure that we can compare our expected state to the actual state. If you have ever worked with a flaky deployment pipeline, tracking when something has successfully made it to production can be tricky in an event-based setup.</p>
<p>&quot;The deployment pipeline failed, so that means we didn&#x27;t deploy&quot;, - I have heard myself say - not realizing that what failed was sending a success email after the pipeline deployed all the code.</p>
<p>With Git&#x27;s version control as the source of truth, this becomes easier. Now, we need to expose the SHA of the commit in the application.</p>
<p>For a web resource, an excellent way to do this could be through a <code>/.well-known/deployment-meta.json</code> while if you are running something like Terraform and AWS, you could tag your resources with this SHA - Try to have as few different methods of exposing this information as possible to keep monitoring simple.</p>
<p>With this piece of information, we are ready to create our monitor. Let&#x27;s say we have a Git ref called <code>environments/production</code>, and its HEAD points to what we expect to be in production, now comparing is simply getting the SHA of the HEAD commit of that ref and comparing it to our <code>./well-known/deployment-meta.json</code>. If they match, the environment is in the expected state. If not, it is unhealthy.</p>
<p>From here, there is one addition we can add, which is just a scheduled task that checks the monitor. If it is unhealthy, it retriggers a deployment and, if that fails, raises the alarm - So even if a deployment failed and no one noticed it yet, it will get auto-corrected the next time our simple reconciler runs.</p>
<p>So, now we have a setup where Git tracks the expected state, and we can easily compare the expected state and the actual state. Lastly, we have a reconciliation loop that tries to rectify any discrepancy.</p>
<p>So as a developer, the only thing I need to keep track of is that my Git refs are pointing to the right stuff. Everything else is reconciliation that I don&#x27;t have to worry about - unless it is unreconcilable - and in which case, I will get alerted.</p>
<p>As someone responsible for the infrastructure, the only thing I need to keep track of is that the expected state matches the actual state.</p>
<p>No more multi-tool lookup, complex log dives or timeline reconstruction (until something fails, of course)</p>
<p>This setup can, of course, be extended and standardized to whatever level is required. Still, I believe that the switch from Git being just the code to being the code state makes a lot of daily tasks more straightforward and more transparent, builds a more resilient infrastructure and is worth considering when deciding how you want to do Git.</p></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"A meta talk about Git strategies","published":"2022-12-01","cover":"/_next/static/images/cover-297544fa0162192cde9a2269034c7fd2.png","parts":["main.md"],"id":"a-meta-talk-about-git-strategies","content":"Let me start with a (semi) fictional story; It is Friday, and you and your team have spent the last five weeks working on this excellent new feature. You have written a bunch of unit tests to ensure that you maintain your project's impressive 100% test coverage, and both you, your product owner and the QA testers have all verified that everything is tip-top and ready to go for the launch!\nYou hit the big \"Deploy\" button.\n3-2-1\nSuccess! it is released to production, and everyone gets their glass of Champagne!\n\nYou go home for the weekend satisfied with the great job you did.\n\nOn Monday, you open your email to find it flooded with customers screaming that nothing is working! Oh no, you must have made a mistake!!! So you set about debugging and quickly locate the error message in your monitoring, so you checkout the code from Git and start investigating. But the error that happens isn't even possible. So you spend the entire day debugging, again and again, coming to the same conclusion; This is not possible.\n\nSo finally, you decide to go and read the deployment log line-by-painstakingly-line, and there, on line 13.318, you see it! One of your 12 microservices failed deployment! The deployment used a script with a pipe in it. Unfortunately, the script did not have pipefail configured. The script, therefore, did not generate a non-zero exit code, so the deployment just kept humming along, deploying the remaining 11 with success. This chain of events resulted in a broken infrastructure state and unhappy customers, and you spend the entire Monday debugging and potentially the ENTIRE EXISTANCE coming to an end!\n\nI think most developers would have a story similar to the one above, so why is getting release management right so damn hard? Modern software architecture and the tools that help us are complex machineries, which goes for our deployment tools. Therefore ensuring that every little thing is as planned means that we would have to check hundreds, if not thousands of items, each more to decipher than the last (anyone who has ever tried to solve a broken Xcode builds from an output log will know this).\n\nSo is there a better way? Unfortunately, when things break, any of those thousands of items could be the reason, so when stuff does break, the answer is most likely no, but what about just answering the simple question: \"Is something broken?\". Well, I am glad you asked because I do believe that there is a better way, and it is a way that revolves around Git.\n\n## Git as the expected state\n\nSo I am going to talk about Kubernetes, yet again - A technology I use less and less but, for some reason, ends up being part of my examples more and more often.\n\nAt its core Kubernetes has two conceptually simple tasks; it stores an expected state of the resources that it is supposed to keep track of two; if any of those resources are, in fact, not in the expected state, it tries to right the wrong.\nThis approach means that when we interact with Kubernetes, we don't ask it to perform a specific task - We never tell it, \"create three additional instances of service X,\" but rather \", There should be five instances of service X\".\nThis approach also means that instead of actions and events, we can use reconciliation - no tracking of what was and what is, just what we expect; the rest is the tool's responsibility.\nIt also makes it very easy for Kubernetes to track the health of the infrastructure - it knows the expected state. If the actual state differs, it is in some unhealthy state, and if it is unhealthy, it should either fix it or, failing that, raise the alarm for manual intervention.\n\nSo how does this relate to Git? Well, Git is a version control system. As such, it should keep track of the state of the code. That, to me, doesn't just include when and why but also where - to elaborate: Git is already great at telling when something happened and also why (provided that you write good commit messages), but it should also be able to answer what is the code state in a given context.\n\nSo let's say you have a production environment; a good Git strategy, in my opinion, should be able to answer the question, \"What is the expected code state on production right now?\"\nAnd note the word \"expected\" here; it is crucial because Git is, of course, not able to do deployments or sync environments (in most cases) but what it can do is serve as our expected state that I talked about with Kubernetes.\n\nOur target is to have something with the simplicity of the Kubernetes approach - we declare an expected state, and the tooling enforces this or alerts us if it can not.\n\nNext, we need to ensure that we can compare our expected state to the actual state. If you have ever worked with a flaky deployment pipeline, tracking when something has successfully made it to production can be tricky in an event-based setup.\n\n\"The deployment pipeline failed, so that means we didn't deploy\", - I have heard myself say - not realizing that what failed was sending a success email after the pipeline deployed all the code.\n\nWith Git's version control as the source of truth, this becomes easier. Now, we need to expose the SHA of the commit in the application.\n\nFor a web resource, an excellent way to do this could be through a `/.well-known/deployment-meta.json` while if you are running something like Terraform and AWS, you could tag your resources with this SHA - Try to have as few different methods of exposing this information as possible to keep monitoring simple.\n\nWith this piece of information, we are ready to create our monitor. Let's say we have a Git ref called `environments/production`, and its HEAD points to what we expect to be in production, now comparing is simply getting the SHA of the HEAD commit of that ref and comparing it to our `./well-known/deployment-meta.json`. If they match, the environment is in the expected state. If not, it is unhealthy.\n\nFrom here, there is one addition we can add, which is just a scheduled task that checks the monitor. If it is unhealthy, it retriggers a deployment and, if that fails, raises the alarm - So even if a deployment failed and no one noticed it yet, it will get auto-corrected the next time our simple reconciler runs.\n\nSo, now we have a setup where Git tracks the expected state, and we can easily compare the expected state and the actual state. Lastly, we have a reconciliation loop that tries to rectify any discrepancy.\n\nSo as a developer, the only thing I need to keep track of is that my Git refs are pointing to the right stuff. Everything else is reconciliation that I don't have to worry about - unless it is unreconcilable - and in which case, I will get alerted.\n\nAs someone responsible for the infrastructure, the only thing I need to keep track of is that the expected state matches the actual state.\n\nNo more multi-tool lookup, complex log dives or timeline reconstruction (until something fails, of course)\n\nThis setup can, of course, be extended and standardized to whatever level is required. Still, I believe that the switch from Git being just the code to being the code state makes a lot of daily tasks more straightforward and more transparent, builds a more resilient infrastructure and is worth considering when deciding how you want to do Git.\n","shareImage":null,"stats":{"text":"7 min read","minutes":6.42,"time":385200,"words":1284},"pdfs":{"a4":"/_next/static/assets/bce47cd04b92619ec50dd4a30f5ff179/doc.pdf"}},"profile":{"name":"Morten Olsen","tagline":"“...One part genius, one part crazy”","avatar":"/_next/static/assets/81088f87d426e6303eb363595dd11467/img.jpg","resumeImage":"/_next/static/images/me-edaaa034fb4c83026095ba93b4083432.jpg","email":"hello@buy-me.coffee","github":"morten-olsen","location":"Copenhagen, DK","social":[{"name":"Github","link":"https://github.com/morten-olsen","value":"morten-olsen","logo":"/_next/static/images/github-7c5f8c05922fa324a5a533d0fd5a3837.svg"},{"name":"HackTheBox","link":"https://app.hackthebox.eu/profile/174098","logo":"/_next/static/images/htb-799f360df57a061190c6bf55dbab6ca7.svg"},{"name":"Stack Overflow","link":"https://stackoverflow.com/users/1689055/morten-olsen","logo":"/_next/static/images/stackoverflow-c8af9424a6933414dcb3d2e6eb2031da.svg"},{"name":"Codingame","link":"https://www.codingame.com/profile/8b34b1812baa75715c972bfe190c0aed4552622","logo":"/_next/static/images/codingame-44a2f18003d25b84fde2f4f1705200d0.svg"},{"name":"Linkedin","link":"https://www.linkedin.com/in/mortenolsendk","logo":"/_next/static/images/linkedin-97d4f18c4d584f3356da112e798c75de.svg"}],"platforms":[{"name":"JavaScript","level":5},{"name":"NodeJS","level":5},{"name":"React Native","level":5},{"name":"Typescript","level":5},{"name":"Docker","level":4},{"name":"Linux","level":4},{"name":"CSharp","level":4}],"skills":[{"name":"React","level":5},{"name":"Redux","level":5},{"name":"Webpack","level":5},{"name":"RxJS","level":3},{"name":"Styled-Components","level":5},{"name":"GraphQL","level":4}],"resume":"/_next/static/assets/0915cbc41d6921df0e26790bdc7f4a5d/doc.pdf"}},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"a-meta-talk-about-git-strategies"},"buildId":"6j-c-bk0BX_lPW9TYh8fm","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>