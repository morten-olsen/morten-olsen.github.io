<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/0c78726e5d91bf4aa9dc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0c78726e5d91bf4aa9dc.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e3de07479da4f2477dea.js" as="script"/><link rel="preload" href="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.1761d65b118e23334373.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-551cd39f14fd9e1ec988.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-a62534df3ce3e0d7b7a0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/post/%5Bslug%5D-ad7e8827329fadd62eca.js" as="script"/><style data-styled="" data-styled-version="5.2.3">body{background:#000;color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:18px;margin:0;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-family:'Comfortaa',c-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;margin-top:70px;}/*!sc*/
h1{font-size:3em;line-height:1.2em;}/*!sc*/
p{padding-bottom:20px;-webkit-letter-spacing:1px;-moz-letter-spacing:1px;-ms-letter-spacing:1px;letter-spacing:1px;line-height:1.6em;}/*!sc*/
p::first-letter{font-size:1.3em;}/*!sc*/
data-styled.g1[id="sc-global-jCvjum1"]{content:"sc-global-jCvjum1,"}/*!sc*/
.byiGhj a{-webkit-text-decoration:none;text-decoration:none;color:#3498db;}/*!sc*/
data-styled.g2[id="_app__Header-cdhalw-0"]{content:"byiGhj,"}/*!sc*/
.jxWOBM{width:100%;max-width:900px;margin:auto;padding:50px;}/*!sc*/
data-styled.g3[id="_app__Content-cdhalw-1"]{content:"jxWOBM,"}/*!sc*/
</style></head><body><div id="__next"><nav class="_app__Header-cdhalw-0 byiGhj"><div class="_app__Content-cdhalw-1 jxWOBM"><a href="/">Home</a></div></nav><div class="_app__Content-cdhalw-1 jxWOBM"><article><h1>The Philosophy of a Smart Home</h1><div><p>Important</p><h2>Important concepts</h2><h3>Minimal interactions</h3><p>So the first think I want to point our is <strong>connected home â‰  smart home</strong></p><p>So what do I mean by that? Let me start with an very simple example setup, that we will build upon to illustrate the different concept. Let us say that you have a setup consistant of one connected light bulb in your living room. This removed the hassel of having to get up of the couch and to to the light switch, but now in order to turn on the light you have to find your phone, unlock it, find the app and through an amount of switches turn your light on. You have merly traded on inconvinience for another.</p><p>For a smart home to be a smart home you have to have the &quot;smart&quot; part. This means that in most cases the home should figure out what to do, without you having to do anything or at least as little as possible.</p><h3>Intent driven</h3><p>So most smart home setups are event driven, where some external event is received and that does then fire an action that updates some appliances in the smart home.</p><p>To continue our example from before and actually at a bit of &quot;smart&quot; to it we will add a motion sensor. When this motion sensor detects motion it will turn the light on and if it hasn&#x27;t detected any motion for some time it will turn it of again.</p><p>Nice and simple.</p><p>But from experience I can tell you that this isn&#x27;t always the desired behavior. If for instance you are watching a movie, where you are sitting still for a longer period of time, it is suboptimal since this leads to the issue where mid-movie the light turns on because you have been sitting still for to long and the motion sensor though the room was empty, only to realize that you are still there, and doing its task of ensuring the lights are on.</p><p>To solve this you could start to listen for the TV&#x27;s state. If it is on, then turn off the motion sensor. This indead solves the problem, but it does not scale very well. As anyone who have done larger smart home setups can tell you, keeping track of all events and their effect on the home is hard. Like really hard.</p><p>One way to make this more managable in my opinion, is to add a layer in between the &quot;event -&gt; action&quot; model that is the common one on most home automation platforms, which is the intent layer. For instance in our example before when the motion sensor detects motion in the living room it will fire a &quot;Occupy room&quot; intent, and when the TV turns on it fires an &quot;Watching TV&quot; intent. Then the automations that should react to the can not see what the user wants to do instead of just some arbitary event.
This also means that this intent layer can take more input into considuration when deciding on an intent, isolating this complexity into its own layer.</p><p>To take this one step further, intents should also be able to end, so when the intent &quot;Watching TV&quot; starts, the motion sensor turn of and when the intent stops, they turn back on.</p><h3>Declarative state</h3><p>A declarative state means that you have a stored state representing the desired state of all your appliances. So the idea is that when you want to make changes to the state of your smart home you update the declarative state instead of dispatching an event to the appliance with the desired state. A reconciliation process then runs that looks at all appliances and correct any with incorrect values.</p><p>This may seem like a small distinction but comes with some great advantages. First of all your home automations become completly decopled from the integrations, meaning if you want to test something but not have all your appliances go insane while doing so, you can simply disconnect them all. The only important thing is that the desired state gets updated correctly, then the reconsiliation will take care of the rest.</p><p>The second great advantages if fault tolerance. Say a light bulb doesn&#x27;t get an action fired for it with the tradition event -&gt; action approach; this light will now be stuck in an incorrect state, until another action overrides the incorrect one. With desired state, the reconciliation process will see that the light is set incorrectly compared to the desired state and correct it.</p><h3>Destinct engine</h3><p>The last concept is to seperate the engine and the UI. A lot of the platforms out there comes with their own UI creation tools, which seems great, and is a great thing to have when first getting into home automations. The problem is that it isn&#x27;t very flexible. I want to be able to create an optimized frontend for the platform that I am working with. So if I am developing and app for the phone, I have a lot of power and can do a lot more than if I am building a small wall panel with a dot-matrix display. Therefore I prefer the engine to not bundle a UI but insted expose an easy to integrate realtime API that can work with low powered devices as well.</p><h2>Putting it all together</h2><p>Okay all the core concepts are there, so we are ready to build our platform.</p><p><strong>Event flow</strong></p><ol><li>Event enters the engine</li><li>The intent system tries to interpret the users intent</li><li>The the automations update the declarative state based on the current state and the intent received</li><li>The reconsiliation process updates any devices which does not have the desired state</li></ol><h2>Using settings group to determine desired state</h2></div>Page!</article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"name":"hello-world","mdx":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Important\"), mdx(\"h2\", null, \"Important concepts\"), mdx(\"h3\", null, \"Minimal interactions\"), mdx(\"p\", null, \"So the first think I want to point our is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"connected home \\u2260 smart home\")), mdx(\"p\", null, \"So what do I mean by that? Let me start with an very simple example setup, that we will build upon to illustrate the different concept. Let us say that you have a setup consistant of one connected light bulb in your living room. This removed the hassel of having to get up of the couch and to to the light switch, but now in order to turn on the light you have to find your phone, unlock it, find the app and through an amount of switches turn your light on. You have merly traded on inconvinience for another.\"), mdx(\"p\", null, \"For a smart home to be a smart home you have to have the \\\"smart\\\" part. This means that in most cases the home should figure out what to do, without you having to do anything or at least as little as possible.\"), mdx(\"h3\", null, \"Intent driven\"), mdx(\"p\", null, \"So most smart home setups are event driven, where some external event is received and that does then fire an action that updates some appliances in the smart home.\"), mdx(\"p\", null, \"To continue our example from before and actually at a bit of \\\"smart\\\" to it we will add a motion sensor. When this motion sensor detects motion it will turn the light on and if it hasn't detected any motion for some time it will turn it of again.\"), mdx(\"p\", null, \"Nice and simple.\"), mdx(\"p\", null, \"But from experience I can tell you that this isn't always the desired behavior. If for instance you are watching a movie, where you are sitting still for a longer period of time, it is suboptimal since this leads to the issue where mid-movie the light turns on because you have been sitting still for to long and the motion sensor though the room was empty, only to realize that you are still there, and doing its task of ensuring the lights are on.\"), mdx(\"p\", null, \"To solve this you could start to listen for the TV's state. If it is on, then turn off the motion sensor. This indead solves the problem, but it does not scale very well. As anyone who have done larger smart home setups can tell you, keeping track of all events and their effect on the home is hard. Like really hard.\"), mdx(\"p\", null, \"One way to make this more managable in my opinion, is to add a layer in between the \\\"event -\u003e action\\\" model that is the common one on most home automation platforms, which is the intent layer. For instance in our example before when the motion sensor detects motion in the living room it will fire a \\\"Occupy room\\\" intent, and when the TV turns on it fires an \\\"Watching TV\\\" intent. Then the automations that should react to the can not see what the user wants to do instead of just some arbitary event.\\nThis also means that this intent layer can take more input into considuration when deciding on an intent, isolating this complexity into its own layer.\"), mdx(\"p\", null, \"To take this one step further, intents should also be able to end, so when the intent \\\"Watching TV\\\" starts, the motion sensor turn of and when the intent stops, they turn back on.\"), mdx(\"h3\", null, \"Declarative state\"), mdx(\"p\", null, \"A declarative state means that you have a stored state representing the desired state of all your appliances. So the idea is that when you want to make changes to the state of your smart home you update the declarative state instead of dispatching an event to the appliance with the desired state. A reconciliation process then runs that looks at all appliances and correct any with incorrect values.\"), mdx(\"p\", null, \"This may seem like a small distinction but comes with some great advantages. First of all your home automations become completly decopled from the integrations, meaning if you want to test something but not have all your appliances go insane while doing so, you can simply disconnect them all. The only important thing is that the desired state gets updated correctly, then the reconsiliation will take care of the rest.\"), mdx(\"p\", null, \"The second great advantages if fault tolerance. Say a light bulb doesn't get an action fired for it with the tradition event -\u003e action approach; this light will now be stuck in an incorrect state, until another action overrides the incorrect one. With desired state, the reconciliation process will see that the light is set incorrectly compared to the desired state and correct it.\"), mdx(\"h3\", null, \"Destinct engine\"), mdx(\"p\", null, \"The last concept is to seperate the engine and the UI. A lot of the platforms out there comes with their own UI creation tools, which seems great, and is a great thing to have when first getting into home automations. The problem is that it isn't very flexible. I want to be able to create an optimized frontend for the platform that I am working with. So if I am developing and app for the phone, I have a lot of power and can do a lot more than if I am building a small wall panel with a dot-matrix display. Therefore I prefer the engine to not bundle a UI but insted expose an easy to integrate realtime API that can work with low powered devices as well.\"), mdx(\"h2\", null, \"Putting it all together\"), mdx(\"p\", null, \"Okay all the core concepts are there, so we are ready to build our platform.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Event flow\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Event enters the engine\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The intent system tries to interpret the users intent\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The the automations update the declarative state based on the current state and the intent received\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The reconsiliation process updates any devices which does not have the desired state\")), mdx(\"h2\", null, \"Using settings group to determine desired state\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cp\u003eImportant\u003c/p\u003e\u003ch2\u003eImportant concepts\u003c/h2\u003e\u003ch3\u003eMinimal interactions\u003c/h3\u003e\u003cp\u003eSo the first think I want to point our is \u003cstrong\u003econnected home â‰  smart home\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSo what do I mean by that? Let me start with an very simple example setup, that we will build upon to illustrate the different concept. Let us say that you have a setup consistant of one connected light bulb in your living room. This removed the hassel of having to get up of the couch and to to the light switch, but now in order to turn on the light you have to find your phone, unlock it, find the app and through an amount of switches turn your light on. You have merly traded on inconvinience for another.\u003c/p\u003e\u003cp\u003eFor a smart home to be a smart home you have to have the \u0026quot;smart\u0026quot; part. This means that in most cases the home should figure out what to do, without you having to do anything or at least as little as possible.\u003c/p\u003e\u003ch3\u003eIntent driven\u003c/h3\u003e\u003cp\u003eSo most smart home setups are event driven, where some external event is received and that does then fire an action that updates some appliances in the smart home.\u003c/p\u003e\u003cp\u003eTo continue our example from before and actually at a bit of \u0026quot;smart\u0026quot; to it we will add a motion sensor. When this motion sensor detects motion it will turn the light on and if it hasn\u0026#x27;t detected any motion for some time it will turn it of again.\u003c/p\u003e\u003cp\u003eNice and simple.\u003c/p\u003e\u003cp\u003eBut from experience I can tell you that this isn\u0026#x27;t always the desired behavior. If for instance you are watching a movie, where you are sitting still for a longer period of time, it is suboptimal since this leads to the issue where mid-movie the light turns on because you have been sitting still for to long and the motion sensor though the room was empty, only to realize that you are still there, and doing its task of ensuring the lights are on.\u003c/p\u003e\u003cp\u003eTo solve this you could start to listen for the TV\u0026#x27;s state. If it is on, then turn off the motion sensor. This indead solves the problem, but it does not scale very well. As anyone who have done larger smart home setups can tell you, keeping track of all events and their effect on the home is hard. Like really hard.\u003c/p\u003e\u003cp\u003eOne way to make this more managable in my opinion, is to add a layer in between the \u0026quot;event -\u0026gt; action\u0026quot; model that is the common one on most home automation platforms, which is the intent layer. For instance in our example before when the motion sensor detects motion in the living room it will fire a \u0026quot;Occupy room\u0026quot; intent, and when the TV turns on it fires an \u0026quot;Watching TV\u0026quot; intent. Then the automations that should react to the can not see what the user wants to do instead of just some arbitary event.\nThis also means that this intent layer can take more input into considuration when deciding on an intent, isolating this complexity into its own layer.\u003c/p\u003e\u003cp\u003eTo take this one step further, intents should also be able to end, so when the intent \u0026quot;Watching TV\u0026quot; starts, the motion sensor turn of and when the intent stops, they turn back on.\u003c/p\u003e\u003ch3\u003eDeclarative state\u003c/h3\u003e\u003cp\u003eA declarative state means that you have a stored state representing the desired state of all your appliances. So the idea is that when you want to make changes to the state of your smart home you update the declarative state instead of dispatching an event to the appliance with the desired state. A reconciliation process then runs that looks at all appliances and correct any with incorrect values.\u003c/p\u003e\u003cp\u003eThis may seem like a small distinction but comes with some great advantages. First of all your home automations become completly decopled from the integrations, meaning if you want to test something but not have all your appliances go insane while doing so, you can simply disconnect them all. The only important thing is that the desired state gets updated correctly, then the reconsiliation will take care of the rest.\u003c/p\u003e\u003cp\u003eThe second great advantages if fault tolerance. Say a light bulb doesn\u0026#x27;t get an action fired for it with the tradition event -\u0026gt; action approach; this light will now be stuck in an incorrect state, until another action overrides the incorrect one. With desired state, the reconciliation process will see that the light is set incorrectly compared to the desired state and correct it.\u003c/p\u003e\u003ch3\u003eDestinct engine\u003c/h3\u003e\u003cp\u003eThe last concept is to seperate the engine and the UI. A lot of the platforms out there comes with their own UI creation tools, which seems great, and is a great thing to have when first getting into home automations. The problem is that it isn\u0026#x27;t very flexible. I want to be able to create an optimized frontend for the platform that I am working with. So if I am developing and app for the phone, I have a lot of power and can do a lot more than if I am building a small wall panel with a dot-matrix display. Therefore I prefer the engine to not bundle a UI but insted expose an easy to integrate realtime API that can work with low powered devices as well.\u003c/p\u003e\u003ch2\u003ePutting it all together\u003c/h2\u003e\u003cp\u003eOkay all the core concepts are there, so we are ready to build our platform.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eEvent flow\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003eEvent enters the engine\u003c/li\u003e\u003cli\u003eThe intent system tries to interpret the users intent\u003c/li\u003e\u003cli\u003eThe the automations update the declarative state based on the current state and the intent received\u003c/li\u003e\u003cli\u003eThe reconsiliation process updates any devices which does not have the desired state\u003c/li\u003e\u003c/ol\u003e\u003ch2\u003eUsing settings group to determine desired state\u003c/h2\u003e","scope":{}},"data":{"title":"The Philosophy of a Smart Home","published":false,"excerpt":"My take on some of the key concept for creating an awesome smart home\n"}}},"__N_SSG":true},"page":"/blog/post/[slug]","query":{"slug":"hello-world"},"buildId":"dhnrbcdAMxWCL3EjfqiFc","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8f31809deb7932dd0187.js"></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.e3de07479da4f2477dea.js" async=""></script><script src="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.1761d65b118e23334373.js" async=""></script><script src="/_next/static/chunks/main-551cd39f14fd9e1ec988.js" async=""></script><script src="/_next/static/chunks/pages/_app-a62534df3ce3e0d7b7a0.js" async=""></script><script src="/_next/static/chunks/pages/blog/post/%5Bslug%5D-ad7e8827329fadd62eca.js" async=""></script><script src="/_next/static/dhnrbcdAMxWCL3EjfqiFc/_buildManifest.js" async=""></script><script src="/_next/static/dhnrbcdAMxWCL3EjfqiFc/_ssgManifest.js" async=""></script></body></html>